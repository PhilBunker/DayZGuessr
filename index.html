<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Panoramic View with HDR</title>
    <style>
      body { margin: 0; overflow: hidden; } /* Remove body margins and prevent scroll */
      canvas { display: block; width: 100%; height: 100vh; } /* Canvas takes full viewport height */
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script type="module">
      import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
      import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';
      import { RGBELoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/RGBELoader.js';

      let scene, camera, renderer, controls;

      function init() {
        scene = new THREE.Scene();
        const canvas = document.getElementById("canvas");
        renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight); // Initial size

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100); // Initial aspect ratio
        camera.position.set(0, 0, 0.1);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableZoom = false;
        controls.enablePan = true;
        controls.rotateSpeed = -0.3;

        // Modify pan speed based on FOV
        controls.getPanSpeed = function() {
          return 0.1 * camera.fov / 75;
        };

        // Compute the target for a 140° left rotation.
        const phi = THREE.MathUtils.degToRad(140);
        const newTarget = new THREE.Vector3(-Math.sin(phi), 0, -Math.cos(phi));
        camera.lookAt(newTarget);
        controls.target.copy(newTarget);
        controls.update();

        canvas.addEventListener('wheel', function(event) {
          event.preventDefault();
          const zoomSpeed = 0.05;
          camera.fov += event.deltaY * zoomSpeed;
          camera.fov = THREE.MathUtils.clamp(camera.fov, 10, 75);
          camera.updateProjectionMatrix();
        }, { passive: false });

        // Load the HDR texture using RGBELoader instead of TextureLoader
        new RGBELoader()
          .setDataType(THREE.UnsignedByteType) // use UnsignedByteType for compatibility; adjust if needed
          .load('pano.hdr', function(texture) {
            // Set texture mapping for equirectangular projection
            texture.mapping = THREE.EquirectangularReflectionMapping;

            const geometry = new THREE.SphereGeometry(500, 60, 40);
            geometry.scale(-1, 1, 1);
            const material = new THREE.MeshBasicMaterial({ map: texture });
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            animate();
          });

        // Handle window resize
        window.addEventListener('resize', () => {
          const newWidth = window.innerWidth;
          const newHeight = window.innerHeight;
          camera.aspect = newWidth / newHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(newWidth, newHeight);
        });
      }

      function animate() {
         requestAnimationFrame(animate);
         const baseFov = 75;
         const baseSpeed = -0.3;
         controls.rotateSpeed = (camera.fov / baseFov) * baseSpeed;
         controls.update();
         renderer.render(scene, camera);
      }

      init();
    </script>
  </body>
</html>